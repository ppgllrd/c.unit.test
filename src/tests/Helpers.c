/*============================================================================*/
/* Helper functions for CircularLinkedList                                    */
/* Pepe Gallardo, 2025                                                        */
/*============================================================================*/

#include "Helpers.h"

#define UNIT_TEST_MEMORY_TRACKING
#include "test/unit/UnitTest.h"

struct X* _x(int B,struct X*C){struct X*A=malloc(sizeof(struct X));*A=(struct X){B,C};return A;}
struct Y* _n(int G[],size_t F){struct Y*A=malloc(sizeof(struct Y));struct X*B,*C;if(F){int*D=G+--F;B=C=_x(*D--,NULL);for(size_t E=F;E;--E)B=_x(*D--,B);F++,C->x=B;}*A=(struct Y){C,F};return A;}
void _p(char*H,size_t I,struct Y*A){struct X*B=A->x;if(B==NULL){snprintf(H,I,"CircularLinkedList()");return;}struct X*first=B->x;if(first==NULL){snprintf(H,I,"CircularLinkedList()");return;}struct X*current=first;size_t actual_count=0;size_t max_iter=(A->s>0)?(A->s*2+10):100;while(actual_count<max_iter&&current!=NULL){actual_count++;current=current->x;if(current==first)break;}size_t C=0;int n=snprintf(H+C,I-C,"CircularLinkedList(");if(n<0||(size_t)n>=I-C)return;C+=n;B=first;for(size_t i=0;i<actual_count;i++){n=snprintf(H+C,I-C,i==actual_count-1?"%d":"%d,",B->i);if(n<0||(size_t)n>=I-C)break;C+=n;B=B->x;}n=snprintf(H+C,I-C,")");}
int _c(struct Y*F,struct Y*G){if(F->s^G->s)return 0;struct X*C=F->x,*D=G->x;size_t A=F->s,B=G->s;int E=1;if(A^B)return 0;while(A--){if(C->i^D->i){E=0;break;}C=C->x;D=D->x;}return E&&(C==F->x&&D==G->x);}
int _v(struct Y*A,char*buf,size_t size){if(!A){snprintf(buf,size,"List pointer is NULL");return 0;}if(A->s==0)return A->x==NULL?1:(snprintf(buf,size,"Empty list (size=0) but p_last is not NULL"),0);if(!A->x){snprintf(buf,size,"Non-empty list (size=%zu) but p_last is NULL",A->s);return 0;}struct X*p_last=A->x,*p_first=p_last->x;if(!p_first){snprintf(buf,size,"p_last->p_next (first node) is NULL");return 0;}if(A->s==1)return(p_first!=p_last)?(snprintf(buf,size,"Single node list: first node (%p) != last node (%p)",(void*)p_first,(void*)p_last),0):(p_first->x!=p_first)?(snprintf(buf,size,"Single node must point to itself, but points to %p",(void*)p_first->x),0):1;struct X**visited=malloc(sizeof(struct X*)*(A->s+1));if(!visited){snprintf(buf,size,"Internal validation error: malloc failed");return 0;}struct X*current=p_first;size_t counted=0;for(size_t i=0;i<A->s+1;i++){if(!current){snprintf(buf,size,"NULL pointer found at position %zu (expected %zu nodes)",counted,A->s);free(visited);return 0;}visited[counted++]=current;current=current->x;if(current==p_first)break;if(counted>A->s){snprintf(buf,size,"List is not circular: traversed %zu nodes without returning to start (size=%zu)",counted,A->s);free(visited);return 0;}}if(counted!=A->s){snprintf(buf,size,"Node count mismatch: counted %zu nodes but size field is %zu",counted,A->s);free(visited);return 0;}if(current!=p_first){snprintf(buf,size,"List is not circular: after %zu iterations, ended at %p instead of first node %p",counted,(void*)current,(void*)p_first);free(visited);return 0;}if(visited[counted-1]!=p_last){snprintf(buf,size,"p_last inconsistency: stored p_last is %p but actual last node is %p",(void*)p_last,(void*)visited[counted-1]);free(visited);return 0;}for(size_t i=0;i<counted-1;i++){for(size_t j=i+1;j<counted;j++){if(visited[i]==visited[j]){snprintf(buf,size,"Duplicate node detected: node at position %zu and %zu have same address %p",i,j,(void*)visited[i]);free(visited);return 0;}}}free(visited);return 1;}